\documentclass[11pt]{article}
\usepackage{geometry}                		
\geometry{letterpaper}                   		
\usepackage{graphicx}   
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{longtable}
%--------------------------------------------------------------------------------------------------------------------------------------


\title{\vspace{4cm} 
	 Sfwr Eng 2XB3 - The Scrabbler}      % tags are self explanatory
\author{ 
	Group 33 \\       % \\  means newline
	Greg Barkans \\
	Curtis Milo \\
	Colin Gillespie \\
	 \vspace{1cm} \\
	Prof: Dr. Samvi \\
	Lab: L01 \\
	 \vspace{2cm} \\
}
\date{}
\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
%Design Documentation\\

%---------------------SECTION 1: MIS--------
\section{MIS (Public API)}

%-----BST
\subsection{Class BST}

\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{public BST()} & Creates an empty Binary search tree \\
\hline
\textbf{public void insert(int key, Word value)} & Given a key for the length of the string,  the string value will be associated with the key given;  values with the same key will not be over written.\\
\hline
\textbf{public Word search(int key, String word)} & Given a key of the length of the string and the word we wish to find, we will return the reference to an object that holds both the word itself and the score that is associated with the word.\\
\hline
\textbf{public  boolean isWord(int key, String word)} & Determines if the string inputted belongs to our list of words.\\
\hline
\textbf{public Word[] matchesPattern(int key, String[] regExpArray)} & Given the length of the string in key, will return all the strings where each string character matches the same index of regExpArray.\\
\hline
\end{tabular}


%------------TrieST
\subsection{Class TrieST}

\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{public TrieST()} & Creates an empty trie with the first node being empty\\
\hline
\textbf{public void insertWord(Word word)} & Will add the given word in the proper location into the trie. \\
\hline
\textbf{public Word search(String word)} & Will return the Word abstract data type that is associated with the string word\\
\hline
\textbf{public Word[] matchPattern(String[] regExpArray)} & Returns all the words in the trie that match the pattern of the regular expression\\
\hline
\end{tabular}

%------Word ADT
\subsection{Class Word}

\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{public Word(String word)} & Creates an object with 2 fields, one that stores the String word and one that is the score of the object based on the rules of the scrabble board.\\
\hline
\textbf{public int setScore(int val)} & Sets the score value of the word to the desired value. \\
\hline
\end{tabular}

%--- Model
\subsection{Class Model}
\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{public Model()} & Creates a new Model object, storing information of the board like what tiles are currently on the grid, what spaces we have highlighted, and holds the list of words that are valid.\\
\hline
\textbf{public Word[] matchTiles()} & Creates an array of the Words, This will represent the words that we can make given the state of the board and the users tiles.\\
\hline
\textbf{public String[] createRegex()} & Will create an array where each element will correspond to a regular expression for one character of a word. This is determined based on what pieces are currently on the board.\\
\hline
\textbf{public Word[] getMatches(int number)} & Creates an array of size number or less in a sorted order where the 0 index will have the highest score value.\\
\hline
\end{tabular}

%-----Controller
\subsection{Class Controller}
\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
%
\textbf{public void Controller()} & Creates a new controller for the interface.html page, this is only instantiated when the page loads.\\
%
\hline
\textbf{public static void onGridClick(htmlClickEvent e)} & Depending on the state the controller this will either add either ask to input a letter or will highlight the square that was clicked.\\
%
\hline
\textbf{public static void onNextClick()} & Will change the state of the website one forward and will update the view to match our new state.\\
%
\hline
\textbf{public static void onBackClick()} & Will change the state of the website one back and will update the view to match our new state.\\
%
\hline
\textbf{public void setTiles()} & Will retrieve the inputted tiles from the HTML input boxes and will set the field of in model to be a list of these tiles.\\
%
\hline
\textbf{public void resetN()} & Button event handler to handle when we click the reset button. This will simply refresh the page.\\
%
\hline
\end{tabular}

%---- View
\subsection{Class View}
\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{public View(Canvas  canvasID)} & Uses the canvas given to create a new 7x7 scrabble board view.\\
%
\hline
\textbf{public void addLetter(char letter, int x, int y)} & Will add a Letter to our canvas at the position of x and y.\\
%
\hline
\textbf{public void addHLetter(char letter,int x, int y)} & Adds a highlighted to the screen.\\
%
\hline
\textbf{public void highlight(char letter, int x, int y)} & Adds a black highlighted square to the screen.\\
%
\hline
\textbf{public void updatePStatus(String string)} & Updates the message displayed to the user with the string passed in.\\
%
\hline
\textbf{public void updateResult(String[] results)} & Updates the result message box with the values from results.\\
\hline
\end{tabular}

%---------------------------------------MID----------------------------------------------------
\newpage
\section{MID}
\subsection{Class BST }

A BST That is used to separate the strings of different lengths. The value of the BST is a trie symbol table that will hold all of the words of this length

\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{Fields} &  Node root: The starting Node of the BST \\
\hline
\textbf{private class Node} & 
\begin{itemize}
	\item The length of the strings affiliated with the trie.
	\item Two Node references for key values less than and key values greater then key.
	\item The value of this node will be a Trie which holds all the words of the given length.
\end{itemize} \\
\hline
\textbf{private void insertREC(Node node, int key, Word value)} &

Will recursively search for the Node associated with with the inputted key. Once they key is found it will check to see if we have an undefined trie symbol table then we will instantiate one. Then we call the insert method for the trie symbol table to add the word.\\
\hline
\textbf{private Word[] matchPatternREC(Node node, int key, String[] regExpArray)} &

Will recursively find the node associated with our key, Then will call the trie symbol table matchPattern method to return any word such that all of the characters match each element of the regular expression array. \\
\hline
\textbf{private TrieST searchREC(Node node, int key)} &

Recursively find the Node associated with the key and will then return the trie symbol table associated with Node.\\
\hline
\end{tabular}
%-----------TrieST------------------
\subsection{Class TrieST}

An Implementation of a trie symbol table where the root of table will have a null character value. The table has an an array of children where each node will have a node associated with a letter  [a-z]. If this is a valid word in our dictionary then we will have Word Object within wordVal.\\
\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{Fields} & RNode root: The starting RNode of the trie symbol table, where the character value is the null character.\\
\hline
\textbf{private class RNode} &
\begin{itemize}
	\item The character at the position the height from the root.
	\item An array of the references to Nodes that hold character next in our String.
	\item If the sequence to get to this node and this nodes value create a word, then the field wordVal will Store a Word Object.
\end{itemize} \\
\hline
\textbf{private void insertWordREC(RNode node, Word wordInput,int charAT)} & Will first properly define the current Node if we have any null references for: The Node itself, The Node's children and there values. Then if we are at the length of our string, then we will set the value of wordVal to the input Word. If not then we will find the next Node to visit and preform recursion on this Node.\\
\hline
\textbf{private Word searchREC(RNode node, String wordInput,int charAT)} & Recursively will find the Node with a path associated with wordInput. Then we will return the value of wordVal (returns null if it is not a word).\\
\hline
\textbf{private void matchPatternREC(RNode node, Word[] combinations, String[] regExpArray, int charAT)} & Checks each child to see if the regular expression regExpArray[charAT] matches the values any of the children of a this Node. If the pattern then we will preform recursion on this Node to see if the next regular expressions matches. Our base case is either do not have a value or any more children where we simply return, or when we have a reached the end of our regular expression array, if we do not have a Word at this node we will return but if we do have a Word then will add this value to our array.\\
\hline
\end{tabular}
%-----------Word------------------
\subsection{Class Word}
\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{Fields} &
\begin{itemize}
	\item String word: The string of the word that we are storing.
	\item int score: The number value that we assign to the word.
\end{itemize} \\
%
\hline
\textbf{private class scoreRules} &
\begin{itemize}
	\item Regular Expression regEX: A regular expression for the letters that fall into this word.
	\item int score: The score pertaining to this regular expression.
\end{itemize} \\
%
\hline
\textbf{private int getScore(String word)} & Creates score rules for every letter in the alphabet for the rules scrabble. Then will some the total score for the string where for every characters in word such that there exists a rule for that letter.\\
\hline
\end{tabular}
%
%-------------- MODEL----------------------------
%
\subsection{Class Model}

\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{Fields} & 
\begin{itemize}
	\item String  [ROWS][COLUMNS] grid: holds the character held on every space of the board. 
	\item String [ROWS][COLUMS] hl\_grid: hold if the space of the grid is highlighted or not.
	\item Word[] words: holds all of the words that match our current state of the board once the onNextClick has reached the result state.
	\item Heap heap: used to implement a priority queue for the our list of words.
	\item char[] tiles:  holds all of the tiles the user has once the onNextClick has reached the result state.
\end{itemize} \\
\hline
\textbf{public Object createRegex()} & (TODO: Greg explains how it works)\\
%
\hline
\textbf{public void sortMatches(Word[] matches)} & Adds all of the Words that match the conditions to our heap.\\
\hline
\textbf{private String grabWord(int i, int j, String dir)} & Will grab the array of characters that are perpendicular to the highlighted tiles \\
\hline
\textbf{private RegExp modifyRegex(int i, int j, String d, String reg)} &
(TODO: Greg explain how it works,  consider renaming variables)\\
\hline
\textbf{private boolean adj(int i, int j, String d)} & Checks for an adjacent highlight in the same direction. \\
\hline
\textbf{private Object findHl()} & Returns the fist occurrence of a highlighted piece and if the direction is vertical, horizontal or single.\\
\hline
\textbf{private void initGrid(int rows,int columns)} & Creates a grid of size rows X columns initialized to to an empty square. \\
\hline
\textbf{private BST getDictionary()} & Reads in from the data sheet of possible words for each word, it will create a new Word Object and will insert it into the BST.\\
\hline
\end{tabular}

\subsection{private class Heap}
\textbf{Uses this.word from parent model}

\begin{tabular}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
%
\textbf{private Heap()} & Set's our parent field this.word to an empty heap.\\
%
\hline
\textbf{private int size()} & Returns the number of elements within the heap.\\
%
\hline 
\textbf{private void exch(int i, int j)} & Swaps the Words at positions i and j.\\
%
\hline
\textbf{private void less(int i, int j)} & Returns if the score of our score at position i is less then our word at position j.\\
%
\hline
\textbf{private void add(Word wordADT)} & Adds a new Item to the bottom of the heap, then swims the Word to the proper location in the heap\\
%
\hline
\textbf{private Word top()} & Will return the our largest element on our heap if our heap is not empty.\\
%
\hline
\textbf{private Word pop()} & Will return and delete the our largest element on our heap if our heap is not empty. We first move the max node to the bottom, remove the max from the heap, then sink our new top Word.\\
%
\hline
\textbf{private void sink(int index)} & Will compare the parent Word at index to its children and will swap and repeat if the score of one of the children is larger then the parent\\
%
\hline
\textbf{private void swim(int index)} & Will compare the child Word at index to its parent and will swap and repeat if the score of one of the parent is smaller then the child\\
\hline
\end{tabular}

%------ CONTROLLER
\newpage
\subsection{Class Controller }
\begin{longtable}{|p{0.4 \textwidth}|p{0.5\textwidth}|}
\hline
\textbf{Fields} & 
\begin{itemize}
	\item Canvas canvasID: the reference to the Canvas on the html, used to draw the grid
	\item Button nextButton: the reference to the Next Button on the HTML.
	\item Button backButton: the reference to the Back Button on the HTML.
	\item Button resetButton: the reference to the Reset Button on the HTML.
\end{itemize} \\
%
\hline
\textbf{public void onGridClick(htmlClickEvent e)} & 
\begin{itemize}
	\item Letters State: Asks for input for the tile that was clicked on
	\item Highlight State: Will highlight or remove the highlighting on the grid square clicked on
\end{itemize} \\
%
\hline
\textbf{public void onNextClick()} & 
\begin{itemize}
	\item Letters State: Change the State to Highlight and update the View
	\item Highlight State: Will move to the Tiles state if there is a valid highlighted row on the board
	\item Tiles: Checks to see if all the tiles are valid, if they are then we will move to the Result state.
	\item Result: will retrieve all of the valid words for this location and will update the View to display them
\end{itemize}\\
%
\hline
\textbf{public void onBackClick()} & 
\begin{itemize}
	\item Letters State: Nothing
	\item Highlight State: Change state to Letters
	\item Tiles: Change state to Highlight
	\item Result: Change state to Tiles
\end{itemize} \\
%
\hline
\textbf{public boolean tileCheck()} & Returns true if all of the inputs for the tiles are one character that is a letter or - or ?\\
%
\hline
\textbf{private boolean hl\_check()} & Returns true if we have between 1 and 7 spaces highlighted in a row.\\
%
\hline
\textbf{private String getLetter(int x\_Pos, int y\_Pos)} & Returns The String that is in the location of x\_Pos, Y\_Pos on the grid.\\
%
\hline
\textbf{private Object getClick(htmlClickEvent e)} & gets the position on the grid that was clicked by using the normalize function. Returns a pair of x and y. \\
%
\hline
\textbf{private String getLetter(int x\_Pos, int y\_Pos)} & Returns the modified numbers of where the user clicked such that it corresponds to the coordinate system of the grid arrays.
Removing such things like offsets and grid size to get a how number between [0,6]. \\
\hline
\end{longtable}
\end{document}
